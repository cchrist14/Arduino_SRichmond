# Arduino_SRichmond
EM31 Documentation
Arduino codes for water-quality sensors and EM31 device. All code is developed by Susan Richmond as part of her Master's thesis at UW-Madison in the Department of Geological Engineering.
Included at the top of the code are four libraries which are necessary for using the GPS and microSD card. These include the TinyGPS++ and built-in SoftwareSerial libraries for the GPS and the built-in SPI and SD libraries for the microSD card. In addition, the column headers for the data file and the sampling rate are also defined at the beginning of the code. We set the sampling rate to collect measurements with a sampling interval of two seconds. Sampling any faster than this makes it difficult to hit the button so that the system can detect it between measurements.
The code begins by executing a setup phase once upon startup. In this phase, all the necessary communications and pins are set up and a file is created to store the data. First, communication is initialized with the GPS and microSD card. Then, the digital pins connected to pins D, E, and F of the recorder connector are set as inputs so the state of the pins can be read. Next, the digital pins used to control the LEDs are set as outputs so they can be used to turn the LEDs on and off. Once the LED pins are set up, the pin corresponding to the red power LED is set to high to turn on the LED and indicate that the system has power. Finally, the system creates and names a new file to store the data.
To name a new file, the system uses GPS data to create a name with the following format: DDHHMMSS.csv. To do this, the system must first wait for the GPS to obtain a signal before it can pull the time information to name the file. First, until the GPS location data are updated, the system continuously checks if new data are available from the GPS and reads and parses any available data using the functions of the TinyGPS++ library. Then, to ensure the time data are valid, the system waits until the day is not equal to 0 (itâ€™s default value) and once again continuously checks if new data are available from the GPS and reads and parses any available data while waiting. Once the GPS data are valid, a function is run to name the file.
The function that names the file begins by clearing the variable that holds the file name so the new file name can be constructed. Then it pulls the day, hour, minute, and second from the GPS and uses this data to create the file name with the DDHHMMSS.csv format. Finally, this function runs another function which cycles through the column headers defined at the beginning of the file and prints them to the newly created file. Now the file is ready to begin storing data and the setup phase is complete.
Next the code enters the loop phase, a phase which continues to repeat endlessly and during which data are collected and stored automatically. First, the code checks if the button has been pressed. To do this, the code reads the voltage across pins A and B of the recorder connector and checks if the voltage is above 2 V. Through experimentation it was determined that during normal operation, the voltage across pins A and B (which corresponds to the electrical conductivity) does not exceed 2 V, however, when the button is pressed and pin G is hooked up to a digital pin, the voltage across pins A and B briefly spikes above 2 V. If the button was pressed, the code sets a variable to indicate that the button was pressed, waits two seconds to make sure the voltage has restabilized, then, if GPS data are available, runs the function to log the data. In the case where the button has been pressed, the code checks if GPS is available in case the specific location at which the button was pressed is important. For the automatic measurements, data are logged regardless of whether GPS data are available and valid. If the function indicates that data were successfully logged, the code blinks the green LED to indicate that data were logged with the button indicator. Finally, the variable to indicate that the button was pressed is reset.
If the code determines that the button was not pressed, the code uses the time of the last log and the sampling rate to determine if it is time to take another automatic measurement, which it does whenever two seconds has passed since the last automatic measurement was recorded. If it is time to take a new measurement, the code runs the same function to log the data. If the function indicates that the data were successfully logged, the code then sets the time of the last data log to the current time and this time blinks the blue LED to indicate that automatic data were logged. At the very end of the loop phase the code checks if new GPS data are available, and if there are it reads and parses the new data using the TinyGPS++ functions. Once the loop phase is complete, the code starts from the beginning and checks once again if the button has been pressed.
To log the data, the same function is used regardless of whether or not the button has been pressed. First the code checks the state of pins D, E, and F which are used to indicate the range and reads the voltage across pins A and B of the recorder connector. The code then uses the state combinations from Table 3.1.1 to determine the range. Next, the code uses the range and voltage reading to calculate the electrical conductivity. Once the conductivity has been calculated, the code then begins logging data to the microSD card. First, the code checks if there is new GPS data available. If new data are available the code logs the longitude, latitude, altitude, date, time, and number of satellites. If no new data are available, the code skips these entries. Next, the code logs the range and electrical conductivity reading in mS/m. Finally, the code checks the variable indicating if the button was pressed, and if it was it logs a B next to the data to indicate that this measurement corresponds to the time and location where the button was pressed. The code then returns to the loop phase and indicates whether or not the data were successfully logged.
